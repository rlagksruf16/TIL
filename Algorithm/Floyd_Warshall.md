### 플로이드 와샬 알고리즘이란?

다익스트라 알고리즘/벨만-포드 알고리즘과는 다르게 하나의 정점에서 하나의 정점이 아닌 **모든 정점에서 모든 정점으로의** 최단 경로를 구하는 알고리즘

- 다익스트라 알고리즘이 가장 적은 비용을 하나씩 선택했다면 프로이드 와샬을 **거쳐가는 정점을 기준**으로 알고리즘을 수행하는 특징이 존재

**특징**

1. **모든 정점에서 모든 정점으로의 최단 경로 구하는 알고리즘**
2. **간선이 음수일 경우에도 활용 가능 → 순환이 없다는 가정하에**

### 시간복잡도

→ 3개의 반복문을 통해 **O(n^3)**

### 알고리즘 구현 방법

1. 시작점, 도착점 사이의 거리를 2차원 배열로 초기화
2. 각각의 노드를 거쳐가는 지점으로 생각하고 둘 중의 최소 비용을 계산
    - X → Y 로 가는 비용
    - X → 거치는 지점 + 거치는 지점 → Y로 가는 비용
3. 2번 과정을 모든 노드에 반복

### 코드

```cpp
#include <stdio.h>

int num = 4;
int INF = 987654321;

int a[4][4] = {
	{0, 5, INF, 8},
	{7, 0, 9, INF},
	{2, INF, 0, 4},
	{INF, INF, 3, 0},
};

void f() {
	int d[num][num];

	for(int i = 0; i < num; i++) {
		for(int j = 0; j < num; j++) {
			d[i][j] = a[i][j];
		}
	}

	for(int k = 0; k < num; k++) {
		for(int i = 0; i < num; i++) {
			for(int j = 0; j < num; j++) {
				if(d[i][k] + d[k][j] < d[i][j])
					d[i][j] = d[i][k] + d[k][j];
			}
		}
	}

	for(int i = 0; i < num; i++) {
		for(int j = 0; j <num; j++) {
			printf("%3d ", d[i][j]);
		}
		printf("\n");
	}
}

int main(void) {
	f();
}		
```

### 참고자료

[안경잡이개발자 : 네이버 블로그](https://blog.naver.com/ndb796/221234427842)